# this is a comment
# token types 
true             # this is a bool
1                # this is a number token
"hello world!"   # this is a string token

# numbers , strings, and bools will be pushed onto the stack automatically 
# the current program in the stack should look like this
# STACK: [true] [1] [hello world!]

println # this will print the string "hello world!" to the output since
# that string was the last to be placed on the stack

println # this will print x to the output since the string "hello world!" was used for the 
# last println

println # this will print 1 to the output since both the string and the identifier have been used or popped from
# the stack

# some symbos and words will be processed as operators and functions
# operators are symbols and functions are keywords like "println"

# they are processed seprately 

println 1 + 2 # -> print produce a stack like [1] [2] [+] [println]
# but 


1 2 + println # -> will get parsed into [1] [2] [println] [+] which will throw an error
# this is becuase the symbols and functions get parsed seprately. to fix this do


(1 2 +) println # -> by wrapping certain tokens into parentheses, this will correctly produce [1] [2] [+] [println] 

# in order to ease programming using a stack base system, the parser uses a shunting yard algo to
# rearrange the tokens for you

println(1 + 2) # will be parsed into [1] [2] [+] [println] automatically
# for the math operations a shunting yard algo is used to convert infix notation to postfix notation
# however the parser will also do the same thing with built in functions such as println and put them at the very end.
# in order to be able to order your function calls properly there are 3 ways


# method 1:
# parentheses will pop off the last function after reaching a ")" this will cuase a function to jump from one side
# to the other side like this.
#
#              print("hello")                                      ("hello") println
#              ^     ------->^ and be placed here and converted to           ^
#              this will end up gettig parsed into [hello] [println] which is the correct order
#              this method only works on built in functions, not user created functions (hopefully this will be added)

# method 2:
# by using the colon symbol ":", you can force the last function to be popped off immediately
"hello " "world" reverse print print # will output "worldhello"...thats not what we want, lets see the stack
# [hello ] [world] [print] [print] [reverse] ah, it looks like our parser has placed reverse after our two print statements, lets fix that



"hello " "world" reverse: print print # it looks like this works because reverse has been placed before the two print statments by 
# using the colon

#methon 3: the semi colon does the same thing as the colon but it will pop EVERY function directly on the stack that has not yet been popped
# this is useful



print "hello " "world\n" concat; # this will be converted into ->  [hello ] [world\n] [concat] [print]

#todo
#    - setarray functions
#    - multi line comments
#    - ignore underscore for long numbers?? 2_000?
#    - declare empty variables?
#    - make some variables immutable
#    - add readline and such
#    - add data structure( stacks list queues dictionaries arrays ) ability to index into arrays or blocks
#    - type aliasing (person -> strings token) 
#    - type conversion
#    - return stuff form inside a block
#    - loops ( for in while repeat untill )
#    - string utilities 
#    - if elif else
#    - better error handling
#    - randomize function



# anything that is not a string, number, bool or some symbols will be treated as functions, in order to treat them as the others,
# simply add a colon to the end or ()


# hello world!
println("hello world!")



# variables (knots) when you create a knot you are tying the identifier to a token
# your identifier will be treated like a function in the parser, to call it use ()
# or to treat it like a variable use a colon after the name like "identifier:"
tie(name: "bingo")
println(name)

tie(name: 100)
println(name)




# if true {println("hello world")}